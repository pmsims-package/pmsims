% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_sample_size.R
\name{calculate_sample_size}
\alias{calculate_sample_size}
\title{Calculate the minimum sample size required to develop a prediction model}
\usage{
calculate_sample_size(
  data,
  model = NULL,
  performance_function = NULL,
  target_performance,
  test_n,
  tune_param = NULL,
  large_sample_performance = NULL,
  tune_args = list(),
  min_sample_size,
  max_sample_size,
  n_reps,
  n_sample_sizes = 10,
  n_init = 4
)
}
\arguments{
\item{performance_function}{A function which takes a a test dataset and model object as argments and returns a performance metric}

\item{target_performance}{The desired performance of the prediction model}

\item{test_n}{The sample size used for testing model performance}

\item{tune_param}{A tuning parameter to be passed to the data generating function}

\item{large_sample_performance}{The desired model performance in a large smaple. This may be specified in place of tune_param. The data generating model is tuned so the desired performance is obtained when n is equal to the max_sample_size.}

\item{tune_args}{A named list of arguments to be passed to tune_generate_data.R. Possible arguments are large_n, min_tune_arg, max_tune_arg, max_interval_expansion, and tolerance. See \code{\link{tune_generate_data}} for more details.}

\item{min_sample_size}{The minimum sample size used in simualations}

\item{max_sample_size}{The maximum sample size used in simulations}

\item{n_reps}{The number of simualtion reps}

\item{n_sample_sizes}{The number of different sample sizes simulations are carried out at}

\item{n_init}{The number of different sample sizes for initialization (before updates)}

\item{data_generating_function}{A function of two parameters, n and a tuning parameter, that returns data for the model function}

\item{model_function}{A function which takes the object returned by the data generating function and fits the analysis model of interest.}
}
\value{
A list of results form the simulation
}
\description{
Minimum working example using the mlpwr package
}
\examples{

library(pROC)

generate_data <- function(n, beta_signal) {
  p_signal <- 10 # number of predictors
  prob_p <- 0.1 # probability of a predictor to be 1
  base_prev <- 0.3 # baseline probability of a positive outcome

  alldata <- rbinom(n * p_signal, 1, prob_p)
  X <- matrix(alldata, nrow = n, ncol = p_signal)
  W_ <- rep(beta_signal, p_signal)
  b0 <- log(base_prev / (1 - base_prev))
  lp <- X \%*\% W_ + b0
  y_prob <- 1 / (1 + exp(-lp))

  # generate outcome
  y <- rbinom(n, 1, y_prob)
  data <- cbind(y, X) |> data.frame()
  x_names <- paste0("x", 1:(ncol(data) - 1))
  data_names <- c("y", x_names)
  colnames(data) <- data_names
  return(data)
}

fit_model <- function(data) {
  logistic_model <- glm("y ~ .", data = data, family = "binomial")
}

# Get performance must be a function of data and a model object
get_performance <- function(data, model) {
  y <- data[, 1]
  x <- data[, -1]
  y_hat <- predict(model, x, type = "response")
  auc <- pROC::auc(y, as.numeric(y_hat), quiet = TRUE)
  return(auc[1])
}

calculate_sample_size(
  data_generating_function = generate_data,
  model_function = fit_model,
  performance_function = get_performance,
  target_performance = 0.75,
  test_n = 10000,
  tune_param = 0.7,
  min_sample_size = 100,
  max_sample_size = 3000,
  n_reps = 100,
  n_sample_sizes = 10
)
}
